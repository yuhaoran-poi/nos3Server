// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: auth.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_auth_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_auth_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_auth_2eproto COMMONNETUE_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct COMMONNETUE_API TableStruct_auth_2eproto {
  static const uint32_t offsets[];
};
COMMONNETUE_API extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_auth_2eproto;
class PBClientLoginReqCmd;
struct PBClientLoginReqCmdDefaultTypeInternal;
COMMONNETUE_API extern PBClientLoginReqCmdDefaultTypeInternal _PBClientLoginReqCmd_default_instance_;
class PBClientLoginRspCmd;
struct PBClientLoginRspCmdDefaultTypeInternal;
COMMONNETUE_API extern PBClientLoginRspCmdDefaultTypeInternal _PBClientLoginRspCmd_default_instance_;
class PBUserLoginData;
struct PBUserLoginDataDefaultTypeInternal;
COMMONNETUE_API extern PBUserLoginDataDefaultTypeInternal _PBUserLoginData_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> COMMONNETUE_API ::PBClientLoginReqCmd* Arena::CreateMaybeMessage<::PBClientLoginReqCmd>(Arena*);
template<> COMMONNETUE_API ::PBClientLoginRspCmd* Arena::CreateMaybeMessage<::PBClientLoginRspCmd>(Arena*);
template<> COMMONNETUE_API ::PBUserLoginData* Arena::CreateMaybeMessage<::PBUserLoginData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class COMMONNETUE_API PBUserLoginData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PBUserLoginData) */ {
 public:
  inline PBUserLoginData() : PBUserLoginData(nullptr) {}
  ~PBUserLoginData() override;
  explicit PROTOBUF_CONSTEXPR PBUserLoginData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PBUserLoginData(const PBUserLoginData& from);
  PBUserLoginData(PBUserLoginData&& from) noexcept
    : PBUserLoginData() {
    *this = ::std::move(from);
  }

  inline PBUserLoginData& operator=(const PBUserLoginData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PBUserLoginData& operator=(PBUserLoginData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PBUserLoginData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PBUserLoginData* internal_default_instance() {
    return reinterpret_cast<const PBUserLoginData*>(
               &_PBUserLoginData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PBUserLoginData& a, PBUserLoginData& b) {
    a.Swap(&b);
  }
  inline void Swap(PBUserLoginData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PBUserLoginData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PBUserLoginData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PBUserLoginData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PBUserLoginData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PBUserLoginData& from) {
    PBUserLoginData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PBUserLoginData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PBUserLoginData";
  }
  protected:
  explicit PBUserLoginData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthkeyFieldNumber = 3,
    kAuthTicketFieldNumber = 4,
    kVersionFieldNumber = 6,
    kPbVersionFieldNumber = 7,
    kUidFieldNumber = 1,
    kSteamIdFieldNumber = 2,
    kMacidFieldNumber = 5,
  };
  // string authkey = 3;
  void clear_authkey();
  const std::string& authkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_authkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_authkey();
  PROTOBUF_NODISCARD std::string* release_authkey();
  void set_allocated_authkey(std::string* authkey);
  private:
  const std::string& _internal_authkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_authkey(const std::string& value);
  std::string* _internal_mutable_authkey();
  public:

  // string auth_ticket = 4;
  void clear_auth_ticket();
  const std::string& auth_ticket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_ticket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_ticket();
  PROTOBUF_NODISCARD std::string* release_auth_ticket();
  void set_allocated_auth_ticket(std::string* auth_ticket);
  private:
  const std::string& _internal_auth_ticket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_ticket(const std::string& value);
  std::string* _internal_mutable_auth_ticket();
  public:

  // string version = 6;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string pb_version = 7;
  void clear_pb_version();
  const std::string& pb_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pb_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pb_version();
  PROTOBUF_NODISCARD std::string* release_pb_version();
  void set_allocated_pb_version(std::string* pb_version);
  private:
  const std::string& _internal_pb_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pb_version(const std::string& value);
  std::string* _internal_mutable_pb_version();
  public:

  // int64 uid = 1;
  void clear_uid();
  int64_t uid() const;
  void set_uid(int64_t value);
  private:
  int64_t _internal_uid() const;
  void _internal_set_uid(int64_t value);
  public:

  // int64 steam_id = 2;
  void clear_steam_id();
  int64_t steam_id() const;
  void set_steam_id(int64_t value);
  private:
  int64_t _internal_steam_id() const;
  void _internal_set_steam_id(int64_t value);
  public:

  // int64 macid = 5;
  void clear_macid();
  int64_t macid() const;
  void set_macid(int64_t value);
  private:
  int64_t _internal_macid() const;
  void _internal_set_macid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PBUserLoginData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr authkey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_ticket_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pb_version_;
    int64_t uid_;
    int64_t steam_id_;
    int64_t macid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class COMMONNETUE_API PBClientLoginReqCmd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PBClientLoginReqCmd) */ {
 public:
  inline PBClientLoginReqCmd() : PBClientLoginReqCmd(nullptr) {}
  ~PBClientLoginReqCmd() override;
  explicit PROTOBUF_CONSTEXPR PBClientLoginReqCmd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PBClientLoginReqCmd(const PBClientLoginReqCmd& from);
  PBClientLoginReqCmd(PBClientLoginReqCmd&& from) noexcept
    : PBClientLoginReqCmd() {
    *this = ::std::move(from);
  }

  inline PBClientLoginReqCmd& operator=(const PBClientLoginReqCmd& from) {
    CopyFrom(from);
    return *this;
  }
  inline PBClientLoginReqCmd& operator=(PBClientLoginReqCmd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PBClientLoginReqCmd& default_instance() {
    return *internal_default_instance();
  }
  static inline const PBClientLoginReqCmd* internal_default_instance() {
    return reinterpret_cast<const PBClientLoginReqCmd*>(
               &_PBClientLoginReqCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PBClientLoginReqCmd& a, PBClientLoginReqCmd& b) {
    a.Swap(&b);
  }
  inline void Swap(PBClientLoginReqCmd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PBClientLoginReqCmd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PBClientLoginReqCmd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PBClientLoginReqCmd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PBClientLoginReqCmd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PBClientLoginReqCmd& from) {
    PBClientLoginReqCmd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PBClientLoginReqCmd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PBClientLoginReqCmd";
  }
  protected:
  explicit PBClientLoginReqCmd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 3,
    kLoginDataFieldNumber = 1,
    kIsRegisterFieldNumber = 2,
  };
  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // .PBUserLoginData login_data = 1;
  bool has_login_data() const;
  private:
  bool _internal_has_login_data() const;
  public:
  void clear_login_data();
  const ::PBUserLoginData& login_data() const;
  PROTOBUF_NODISCARD ::PBUserLoginData* release_login_data();
  ::PBUserLoginData* mutable_login_data();
  void set_allocated_login_data(::PBUserLoginData* login_data);
  private:
  const ::PBUserLoginData& _internal_login_data() const;
  ::PBUserLoginData* _internal_mutable_login_data();
  public:
  void unsafe_arena_set_allocated_login_data(
      ::PBUserLoginData* login_data);
  ::PBUserLoginData* unsafe_arena_release_login_data();

  // bool is_register = 2;
  void clear_is_register();
  bool is_register() const;
  void set_is_register(bool value);
  private:
  bool _internal_is_register() const;
  void _internal_set_is_register(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PBClientLoginReqCmd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
    ::PBUserLoginData* login_data_;
    bool is_register_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// -------------------------------------------------------------------

class COMMONNETUE_API PBClientLoginRspCmd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PBClientLoginRspCmd) */ {
 public:
  inline PBClientLoginRspCmd() : PBClientLoginRspCmd(nullptr) {}
  ~PBClientLoginRspCmd() override;
  explicit PROTOBUF_CONSTEXPR PBClientLoginRspCmd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PBClientLoginRspCmd(const PBClientLoginRspCmd& from);
  PBClientLoginRspCmd(PBClientLoginRspCmd&& from) noexcept
    : PBClientLoginRspCmd() {
    *this = ::std::move(from);
  }

  inline PBClientLoginRspCmd& operator=(const PBClientLoginRspCmd& from) {
    CopyFrom(from);
    return *this;
  }
  inline PBClientLoginRspCmd& operator=(PBClientLoginRspCmd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PBClientLoginRspCmd& default_instance() {
    return *internal_default_instance();
  }
  static inline const PBClientLoginRspCmd* internal_default_instance() {
    return reinterpret_cast<const PBClientLoginRspCmd*>(
               &_PBClientLoginRspCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PBClientLoginRspCmd& a, PBClientLoginRspCmd& b) {
    a.Swap(&b);
  }
  inline void Swap(PBClientLoginRspCmd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PBClientLoginRspCmd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PBClientLoginRspCmd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PBClientLoginRspCmd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PBClientLoginRspCmd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PBClientLoginRspCmd& from) {
    PBClientLoginRspCmd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PBClientLoginRspCmd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PBClientLoginRspCmd";
  }
  protected:
  explicit PBClientLoginRspCmd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kReconnKeyFieldNumber = 5,
    kCodeFieldNumber = 1,
    kNetIdFieldNumber = 4,
    kUidFieldNumber = 3,
  };
  // string error = 2;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // string reconn_key = 5;
  void clear_reconn_key();
  const std::string& reconn_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reconn_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reconn_key();
  PROTOBUF_NODISCARD std::string* release_reconn_key();
  void set_allocated_reconn_key(std::string* reconn_key);
  private:
  const std::string& _internal_reconn_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reconn_key(const std::string& value);
  std::string* _internal_mutable_reconn_key();
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // int32 net_id = 4;
  void clear_net_id();
  int32_t net_id() const;
  void set_net_id(int32_t value);
  private:
  int32_t _internal_net_id() const;
  void _internal_set_net_id(int32_t value);
  public:

  // int64 uid = 3;
  void clear_uid();
  int64_t uid() const;
  void set_uid(int64_t value);
  private:
  int64_t _internal_uid() const;
  void _internal_set_uid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:PBClientLoginRspCmd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reconn_key_;
    int32_t code_;
    int32_t net_id_;
    int64_t uid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_auth_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PBUserLoginData

// int64 uid = 1;
inline void PBUserLoginData::clear_uid() {
  _impl_.uid_ = int64_t{0};
}
inline int64_t PBUserLoginData::_internal_uid() const {
  return _impl_.uid_;
}
inline int64_t PBUserLoginData::uid() const {
  // @@protoc_insertion_point(field_get:PBUserLoginData.uid)
  return _internal_uid();
}
inline void PBUserLoginData::_internal_set_uid(int64_t value) {
  
  _impl_.uid_ = value;
}
inline void PBUserLoginData::set_uid(int64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:PBUserLoginData.uid)
}

// int64 steam_id = 2;
inline void PBUserLoginData::clear_steam_id() {
  _impl_.steam_id_ = int64_t{0};
}
inline int64_t PBUserLoginData::_internal_steam_id() const {
  return _impl_.steam_id_;
}
inline int64_t PBUserLoginData::steam_id() const {
  // @@protoc_insertion_point(field_get:PBUserLoginData.steam_id)
  return _internal_steam_id();
}
inline void PBUserLoginData::_internal_set_steam_id(int64_t value) {
  
  _impl_.steam_id_ = value;
}
inline void PBUserLoginData::set_steam_id(int64_t value) {
  _internal_set_steam_id(value);
  // @@protoc_insertion_point(field_set:PBUserLoginData.steam_id)
}

// string authkey = 3;
inline void PBUserLoginData::clear_authkey() {
  _impl_.authkey_.ClearToEmpty();
}
inline const std::string& PBUserLoginData::authkey() const {
  // @@protoc_insertion_point(field_get:PBUserLoginData.authkey)
  return _internal_authkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PBUserLoginData::set_authkey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.authkey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PBUserLoginData.authkey)
}
inline std::string* PBUserLoginData::mutable_authkey() {
  std::string* _s = _internal_mutable_authkey();
  // @@protoc_insertion_point(field_mutable:PBUserLoginData.authkey)
  return _s;
}
inline const std::string& PBUserLoginData::_internal_authkey() const {
  return _impl_.authkey_.Get();
}
inline void PBUserLoginData::_internal_set_authkey(const std::string& value) {
  
  _impl_.authkey_.Set(value, GetArenaForAllocation());
}
inline std::string* PBUserLoginData::_internal_mutable_authkey() {
  
  return _impl_.authkey_.Mutable(GetArenaForAllocation());
}
inline std::string* PBUserLoginData::release_authkey() {
  // @@protoc_insertion_point(field_release:PBUserLoginData.authkey)
  return _impl_.authkey_.Release();
}
inline void PBUserLoginData::set_allocated_authkey(std::string* authkey) {
  if (authkey != nullptr) {
    
  } else {
    
  }
  _impl_.authkey_.SetAllocated(authkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.authkey_.IsDefault()) {
    _impl_.authkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PBUserLoginData.authkey)
}

// string auth_ticket = 4;
inline void PBUserLoginData::clear_auth_ticket() {
  _impl_.auth_ticket_.ClearToEmpty();
}
inline const std::string& PBUserLoginData::auth_ticket() const {
  // @@protoc_insertion_point(field_get:PBUserLoginData.auth_ticket)
  return _internal_auth_ticket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PBUserLoginData::set_auth_ticket(ArgT0&& arg0, ArgT... args) {
 
 _impl_.auth_ticket_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PBUserLoginData.auth_ticket)
}
inline std::string* PBUserLoginData::mutable_auth_ticket() {
  std::string* _s = _internal_mutable_auth_ticket();
  // @@protoc_insertion_point(field_mutable:PBUserLoginData.auth_ticket)
  return _s;
}
inline const std::string& PBUserLoginData::_internal_auth_ticket() const {
  return _impl_.auth_ticket_.Get();
}
inline void PBUserLoginData::_internal_set_auth_ticket(const std::string& value) {
  
  _impl_.auth_ticket_.Set(value, GetArenaForAllocation());
}
inline std::string* PBUserLoginData::_internal_mutable_auth_ticket() {
  
  return _impl_.auth_ticket_.Mutable(GetArenaForAllocation());
}
inline std::string* PBUserLoginData::release_auth_ticket() {
  // @@protoc_insertion_point(field_release:PBUserLoginData.auth_ticket)
  return _impl_.auth_ticket_.Release();
}
inline void PBUserLoginData::set_allocated_auth_ticket(std::string* auth_ticket) {
  if (auth_ticket != nullptr) {
    
  } else {
    
  }
  _impl_.auth_ticket_.SetAllocated(auth_ticket, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.auth_ticket_.IsDefault()) {
    _impl_.auth_ticket_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PBUserLoginData.auth_ticket)
}

// int64 macid = 5;
inline void PBUserLoginData::clear_macid() {
  _impl_.macid_ = int64_t{0};
}
inline int64_t PBUserLoginData::_internal_macid() const {
  return _impl_.macid_;
}
inline int64_t PBUserLoginData::macid() const {
  // @@protoc_insertion_point(field_get:PBUserLoginData.macid)
  return _internal_macid();
}
inline void PBUserLoginData::_internal_set_macid(int64_t value) {
  
  _impl_.macid_ = value;
}
inline void PBUserLoginData::set_macid(int64_t value) {
  _internal_set_macid(value);
  // @@protoc_insertion_point(field_set:PBUserLoginData.macid)
}

// string version = 6;
inline void PBUserLoginData::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& PBUserLoginData::version() const {
  // @@protoc_insertion_point(field_get:PBUserLoginData.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PBUserLoginData::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PBUserLoginData.version)
}
inline std::string* PBUserLoginData::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:PBUserLoginData.version)
  return _s;
}
inline const std::string& PBUserLoginData::_internal_version() const {
  return _impl_.version_.Get();
}
inline void PBUserLoginData::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* PBUserLoginData::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* PBUserLoginData::release_version() {
  // @@protoc_insertion_point(field_release:PBUserLoginData.version)
  return _impl_.version_.Release();
}
inline void PBUserLoginData::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PBUserLoginData.version)
}

// string pb_version = 7;
inline void PBUserLoginData::clear_pb_version() {
  _impl_.pb_version_.ClearToEmpty();
}
inline const std::string& PBUserLoginData::pb_version() const {
  // @@protoc_insertion_point(field_get:PBUserLoginData.pb_version)
  return _internal_pb_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PBUserLoginData::set_pb_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pb_version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PBUserLoginData.pb_version)
}
inline std::string* PBUserLoginData::mutable_pb_version() {
  std::string* _s = _internal_mutable_pb_version();
  // @@protoc_insertion_point(field_mutable:PBUserLoginData.pb_version)
  return _s;
}
inline const std::string& PBUserLoginData::_internal_pb_version() const {
  return _impl_.pb_version_.Get();
}
inline void PBUserLoginData::_internal_set_pb_version(const std::string& value) {
  
  _impl_.pb_version_.Set(value, GetArenaForAllocation());
}
inline std::string* PBUserLoginData::_internal_mutable_pb_version() {
  
  return _impl_.pb_version_.Mutable(GetArenaForAllocation());
}
inline std::string* PBUserLoginData::release_pb_version() {
  // @@protoc_insertion_point(field_release:PBUserLoginData.pb_version)
  return _impl_.pb_version_.Release();
}
inline void PBUserLoginData::set_allocated_pb_version(std::string* pb_version) {
  if (pb_version != nullptr) {
    
  } else {
    
  }
  _impl_.pb_version_.SetAllocated(pb_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pb_version_.IsDefault()) {
    _impl_.pb_version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PBUserLoginData.pb_version)
}

// -------------------------------------------------------------------

// PBClientLoginReqCmd

// .PBUserLoginData login_data = 1;
inline bool PBClientLoginReqCmd::_internal_has_login_data() const {
  return this != internal_default_instance() && _impl_.login_data_ != nullptr;
}
inline bool PBClientLoginReqCmd::has_login_data() const {
  return _internal_has_login_data();
}
inline void PBClientLoginReqCmd::clear_login_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.login_data_ != nullptr) {
    delete _impl_.login_data_;
  }
  _impl_.login_data_ = nullptr;
}
inline const ::PBUserLoginData& PBClientLoginReqCmd::_internal_login_data() const {
  const ::PBUserLoginData* p = _impl_.login_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::PBUserLoginData&>(
      ::_PBUserLoginData_default_instance_);
}
inline const ::PBUserLoginData& PBClientLoginReqCmd::login_data() const {
  // @@protoc_insertion_point(field_get:PBClientLoginReqCmd.login_data)
  return _internal_login_data();
}
inline void PBClientLoginReqCmd::unsafe_arena_set_allocated_login_data(
    ::PBUserLoginData* login_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.login_data_);
  }
  _impl_.login_data_ = login_data;
  if (login_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:PBClientLoginReqCmd.login_data)
}
inline ::PBUserLoginData* PBClientLoginReqCmd::release_login_data() {
  
  ::PBUserLoginData* temp = _impl_.login_data_;
  _impl_.login_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PBUserLoginData* PBClientLoginReqCmd::unsafe_arena_release_login_data() {
  // @@protoc_insertion_point(field_release:PBClientLoginReqCmd.login_data)
  
  ::PBUserLoginData* temp = _impl_.login_data_;
  _impl_.login_data_ = nullptr;
  return temp;
}
inline ::PBUserLoginData* PBClientLoginReqCmd::_internal_mutable_login_data() {
  
  if (_impl_.login_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::PBUserLoginData>(GetArenaForAllocation());
    _impl_.login_data_ = p;
  }
  return _impl_.login_data_;
}
inline ::PBUserLoginData* PBClientLoginReqCmd::mutable_login_data() {
  ::PBUserLoginData* _msg = _internal_mutable_login_data();
  // @@protoc_insertion_point(field_mutable:PBClientLoginReqCmd.login_data)
  return _msg;
}
inline void PBClientLoginReqCmd::set_allocated_login_data(::PBUserLoginData* login_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.login_data_;
  }
  if (login_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(login_data);
    if (message_arena != submessage_arena) {
      login_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, login_data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.login_data_ = login_data;
  // @@protoc_insertion_point(field_set_allocated:PBClientLoginReqCmd.login_data)
}

// bool is_register = 2;
inline void PBClientLoginReqCmd::clear_is_register() {
  _impl_.is_register_ = false;
}
inline bool PBClientLoginReqCmd::_internal_is_register() const {
  return _impl_.is_register_;
}
inline bool PBClientLoginReqCmd::is_register() const {
  // @@protoc_insertion_point(field_get:PBClientLoginReqCmd.is_register)
  return _internal_is_register();
}
inline void PBClientLoginReqCmd::_internal_set_is_register(bool value) {
  
  _impl_.is_register_ = value;
}
inline void PBClientLoginReqCmd::set_is_register(bool value) {
  _internal_set_is_register(value);
  // @@protoc_insertion_point(field_set:PBClientLoginReqCmd.is_register)
}

// string password = 3;
inline void PBClientLoginReqCmd::clear_password() {
  _impl_.password_.ClearToEmpty();
}
inline const std::string& PBClientLoginReqCmd::password() const {
  // @@protoc_insertion_point(field_get:PBClientLoginReqCmd.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PBClientLoginReqCmd::set_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.password_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PBClientLoginReqCmd.password)
}
inline std::string* PBClientLoginReqCmd::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:PBClientLoginReqCmd.password)
  return _s;
}
inline const std::string& PBClientLoginReqCmd::_internal_password() const {
  return _impl_.password_.Get();
}
inline void PBClientLoginReqCmd::_internal_set_password(const std::string& value) {
  
  _impl_.password_.Set(value, GetArenaForAllocation());
}
inline std::string* PBClientLoginReqCmd::_internal_mutable_password() {
  
  return _impl_.password_.Mutable(GetArenaForAllocation());
}
inline std::string* PBClientLoginReqCmd::release_password() {
  // @@protoc_insertion_point(field_release:PBClientLoginReqCmd.password)
  return _impl_.password_.Release();
}
inline void PBClientLoginReqCmd::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  _impl_.password_.SetAllocated(password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PBClientLoginReqCmd.password)
}

// -------------------------------------------------------------------

// PBClientLoginRspCmd

// int32 code = 1;
inline void PBClientLoginRspCmd::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t PBClientLoginRspCmd::_internal_code() const {
  return _impl_.code_;
}
inline int32_t PBClientLoginRspCmd::code() const {
  // @@protoc_insertion_point(field_get:PBClientLoginRspCmd.code)
  return _internal_code();
}
inline void PBClientLoginRspCmd::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void PBClientLoginRspCmd::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:PBClientLoginRspCmd.code)
}

// string error = 2;
inline void PBClientLoginRspCmd::clear_error() {
  _impl_.error_.ClearToEmpty();
}
inline const std::string& PBClientLoginRspCmd::error() const {
  // @@protoc_insertion_point(field_get:PBClientLoginRspCmd.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PBClientLoginRspCmd::set_error(ArgT0&& arg0, ArgT... args) {
 
 _impl_.error_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PBClientLoginRspCmd.error)
}
inline std::string* PBClientLoginRspCmd::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:PBClientLoginRspCmd.error)
  return _s;
}
inline const std::string& PBClientLoginRspCmd::_internal_error() const {
  return _impl_.error_.Get();
}
inline void PBClientLoginRspCmd::_internal_set_error(const std::string& value) {
  
  _impl_.error_.Set(value, GetArenaForAllocation());
}
inline std::string* PBClientLoginRspCmd::_internal_mutable_error() {
  
  return _impl_.error_.Mutable(GetArenaForAllocation());
}
inline std::string* PBClientLoginRspCmd::release_error() {
  // @@protoc_insertion_point(field_release:PBClientLoginRspCmd.error)
  return _impl_.error_.Release();
}
inline void PBClientLoginRspCmd::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  _impl_.error_.SetAllocated(error, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.error_.IsDefault()) {
    _impl_.error_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PBClientLoginRspCmd.error)
}

// int64 uid = 3;
inline void PBClientLoginRspCmd::clear_uid() {
  _impl_.uid_ = int64_t{0};
}
inline int64_t PBClientLoginRspCmd::_internal_uid() const {
  return _impl_.uid_;
}
inline int64_t PBClientLoginRspCmd::uid() const {
  // @@protoc_insertion_point(field_get:PBClientLoginRspCmd.uid)
  return _internal_uid();
}
inline void PBClientLoginRspCmd::_internal_set_uid(int64_t value) {
  
  _impl_.uid_ = value;
}
inline void PBClientLoginRspCmd::set_uid(int64_t value) {
  _internal_set_uid(value);
  // @@protoc_insertion_point(field_set:PBClientLoginRspCmd.uid)
}

// int32 net_id = 4;
inline void PBClientLoginRspCmd::clear_net_id() {
  _impl_.net_id_ = 0;
}
inline int32_t PBClientLoginRspCmd::_internal_net_id() const {
  return _impl_.net_id_;
}
inline int32_t PBClientLoginRspCmd::net_id() const {
  // @@protoc_insertion_point(field_get:PBClientLoginRspCmd.net_id)
  return _internal_net_id();
}
inline void PBClientLoginRspCmd::_internal_set_net_id(int32_t value) {
  
  _impl_.net_id_ = value;
}
inline void PBClientLoginRspCmd::set_net_id(int32_t value) {
  _internal_set_net_id(value);
  // @@protoc_insertion_point(field_set:PBClientLoginRspCmd.net_id)
}

// string reconn_key = 5;
inline void PBClientLoginRspCmd::clear_reconn_key() {
  _impl_.reconn_key_.ClearToEmpty();
}
inline const std::string& PBClientLoginRspCmd::reconn_key() const {
  // @@protoc_insertion_point(field_get:PBClientLoginRspCmd.reconn_key)
  return _internal_reconn_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PBClientLoginRspCmd::set_reconn_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.reconn_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PBClientLoginRspCmd.reconn_key)
}
inline std::string* PBClientLoginRspCmd::mutable_reconn_key() {
  std::string* _s = _internal_mutable_reconn_key();
  // @@protoc_insertion_point(field_mutable:PBClientLoginRspCmd.reconn_key)
  return _s;
}
inline const std::string& PBClientLoginRspCmd::_internal_reconn_key() const {
  return _impl_.reconn_key_.Get();
}
inline void PBClientLoginRspCmd::_internal_set_reconn_key(const std::string& value) {
  
  _impl_.reconn_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PBClientLoginRspCmd::_internal_mutable_reconn_key() {
  
  return _impl_.reconn_key_.Mutable(GetArenaForAllocation());
}
inline std::string* PBClientLoginRspCmd::release_reconn_key() {
  // @@protoc_insertion_point(field_release:PBClientLoginRspCmd.reconn_key)
  return _impl_.reconn_key_.Release();
}
inline void PBClientLoginRspCmd::set_allocated_reconn_key(std::string* reconn_key) {
  if (reconn_key != nullptr) {
    
  } else {
    
  }
  _impl_.reconn_key_.SetAllocated(reconn_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.reconn_key_.IsDefault()) {
    _impl_.reconn_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PBClientLoginRspCmd.reconn_key)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_auth_2eproto
